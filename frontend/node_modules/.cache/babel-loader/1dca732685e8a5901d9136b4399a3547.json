{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketClient = void 0;\n\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\n\nconst socket_1 = require(\"@cosmjs/socket\");\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst xstream_1 = require(\"xstream\");\n\nconst rpcclient_1 = require(\"./rpcclient\");\n\nfunction defaultErrorHandler(error) {\n  throw error;\n}\n\nfunction toJsonRpcResponse(message) {\n  // this should never happen, but I want an alert if it does\n  if (message.type !== \"message\") {\n    throw new Error(`Unexcepted message type on websocket: ${message.type}`);\n  }\n\n  const jsonRpcEvent = json_rpc_1.parseJsonRpcResponse(JSON.parse(message.data));\n  return jsonRpcEvent;\n}\n\nclass RpcEventProducer {\n  constructor(request, socket) {\n    this.running = false;\n    this.subscriptions = [];\n    this.request = request;\n    this.socket = socket;\n  }\n  /**\n   * Implementation of Producer.start\n   */\n\n\n  start(listener) {\n    if (this.running) {\n      throw Error(\"Already started. Please stop first before restarting.\");\n    }\n\n    this.running = true;\n    this.connectToClient(listener);\n    this.socket.queueRequest(JSON.stringify(this.request));\n  }\n  /**\n   * Implementation of Producer.stop\n   *\n   * Called by the stream when the stream's last listener stopped listening\n   * or when the producer completed.\n   */\n\n\n  stop() {\n    this.running = false; // Tell the server we are done in order to save resources. We cannot wait for the result.\n    // This may fail when socket connection is not open, thus ignore errors in queueRequest\n\n    const endRequest = Object.assign(Object.assign({}, this.request), {\n      method: \"unsubscribe\"\n    });\n\n    try {\n      this.socket.queueRequest(JSON.stringify(endRequest));\n    } catch (error) {\n      if (error instanceof Error && error.message.match(/socket has disconnected/i)) {// ignore\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  connectToClient(listener) {\n    const responseStream = this.socket.events.map(toJsonRpcResponse); // this should unsubscribe itself, so doesn't need to be removed explicitly\n\n    const idSubscription = responseStream.filter(response => response.id === this.request.id).subscribe({\n      next: response => {\n        if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n          this.closeSubscriptions();\n          listener.error(JSON.stringify(response.error));\n        }\n\n        idSubscription.unsubscribe();\n      }\n    }); // this will fire on a response (success or error)\n    // Tendermint adds an \"#event\" suffix for events that follow a previous subscription\n    // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107\n\n    const idEventSubscription = responseStream.filter(response => response.id === this.request.id).subscribe({\n      next: response => {\n        if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n          this.closeSubscriptions();\n          listener.error(JSON.stringify(response.error));\n        } else {\n          listener.next(response.result);\n        }\n      }\n    }); // this will fire in case the websocket disconnects cleanly\n\n    const nonResponseSubscription = responseStream.subscribe({\n      error: error => {\n        this.closeSubscriptions();\n        listener.error(error);\n      },\n      complete: () => {\n        this.closeSubscriptions();\n        listener.complete();\n      }\n    });\n    this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);\n  }\n\n  closeSubscriptions() {\n    for (const subscription of this.subscriptions) {\n      subscription.unsubscribe();\n    } // clear unused subscriptions\n\n\n    this.subscriptions = [];\n  }\n\n}\n\nclass WebsocketClient {\n  constructor() {\n    let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ws://localhost:46657\";\n    let onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultErrorHandler;\n    // Lazily create streams and use the same stream when listening to the same query twice.\n    //\n    // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this\n    // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!\n    this.subscriptionStreams = new Map(); // accept host.name:port and assume ws protocol\n    // make sure we don't end up with ...//websocket\n\n    const path = baseUrl.endsWith(\"/\") ? \"websocket\" : \"/websocket\";\n    const cleanBaseUrl = rpcclient_1.hasProtocol(baseUrl) ? baseUrl : \"ws://\" + baseUrl;\n    this.url = cleanBaseUrl + path;\n    this.socket = new socket_1.ReconnectingSocket(this.url);\n    const errorSubscription = this.socket.events.subscribe({\n      error: error => {\n        onError(error);\n        errorSubscription.unsubscribe();\n      }\n    });\n    this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);\n    this.socket.connect();\n  }\n\n  async execute(request) {\n    const pendingResponse = this.responseForRequestId(request.id);\n    this.socket.queueRequest(JSON.stringify(request));\n    const response = await pendingResponse;\n\n    if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n      throw new Error(JSON.stringify(response.error));\n    }\n\n    return response;\n  }\n\n  listen(request) {\n    if (request.method !== \"subscribe\") {\n      throw new Error(`Request method must be \"subscribe\" to start event listening`);\n    }\n\n    const query = request.params.query;\n\n    if (typeof query !== \"string\") {\n      throw new Error(\"request.params.query must be a string\");\n    }\n\n    if (!this.subscriptionStreams.has(query)) {\n      const producer = new RpcEventProducer(request, this.socket);\n      const stream = xstream_1.Stream.create(producer);\n      this.subscriptionStreams.set(query, stream);\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return this.subscriptionStreams.get(query).filter(response => response.query !== undefined);\n  }\n  /**\n   * Resolves as soon as websocket is connected. execute() queues requests automatically,\n   * so this should be required for testing purposes only.\n   */\n\n\n  async connected() {\n    await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);\n  }\n\n  disconnect() {\n    this.socket.disconnect();\n  }\n\n  async responseForRequestId(id) {\n    return stream_1.firstEvent(this.jsonRpcResponseStream.filter(r => r.id === id));\n  }\n\n}\n\nexports.WebsocketClient = WebsocketClient;","map":{"version":3,"mappings":"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","names":["defaultErrorHandler","error","toJsonRpcResponse","message","type","Error","jsonRpcEvent","json_rpc_1","JSON","parse","data","RpcEventProducer","constructor","request","socket","start","listener","running","connectToClient","queueRequest","stringify","stop","endRequest","method","match","responseStream","events","map","idSubscription","filter","response","id","subscribe","next","closeSubscriptions","unsubscribe","idEventSubscription","result","nonResponseSubscription","complete","subscriptions","push","subscription","WebsocketClient","baseUrl","onError","Map","path","endsWith","cleanBaseUrl","rpcclient_1","url","socket_1","errorSubscription","jsonRpcResponseStream","connect","execute","pendingResponse","responseForRequestId","listen","query","params","subscriptionStreams","has","producer","stream","xstream_1","create","set","get","undefined","connected","connectionStatus","waitFor","Connected","disconnect","stream_1","r","exports"],"sourceRoot":"","sources":["../../src/rpcclients/websocketclient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}