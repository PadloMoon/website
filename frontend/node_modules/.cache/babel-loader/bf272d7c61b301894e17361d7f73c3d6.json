{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectSecp256k1Wallet = void 0;\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst signing_1 = require(\"./signing\");\n/**\n * A wallet that holds a single secp256k1 keypair.\n *\n * If you want to work with BIP39 mnemonics and multiple accounts, use DirectSecp256k1HdWallet.\n */\n\n\nclass DirectSecp256k1Wallet {\n  constructor(privkey, pubkey, prefix) {\n    this.privkey = privkey;\n    this.pubkey = pubkey;\n    this.prefix = prefix;\n  }\n  /**\n   * Creates a DirectSecp256k1Wallet from the given private key\n   *\n   * @param privkey The private key.\n   * @param prefix The bech32 address prefix (human readable part). Defaults to \"cosmos\".\n   */\n\n\n  static async fromKey(privkey) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"cosmos\";\n    const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;\n    return new DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);\n  }\n\n  get address() {\n    return encoding_1.Bech32.encode(this.prefix, amino_1.rawSecp256k1PubkeyToRawAddress(this.pubkey));\n  }\n\n  async getAccounts() {\n    return [{\n      algo: \"secp256k1\",\n      address: this.address,\n      pubkey: this.pubkey\n    }];\n  }\n\n  async signDirect(address, signDoc) {\n    const signBytes = signing_1.makeSignBytes(signDoc);\n\n    if (address !== this.address) {\n      throw new Error(`Address ${address} not found in wallet`);\n    }\n\n    const hashedMessage = crypto_1.sha256(signBytes);\n    const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    const stdSignature = amino_1.encodeSecp256k1Signature(this.pubkey, signatureBytes);\n    return {\n      signed: signDoc,\n      signature: stdSignature\n    };\n  }\n\n}\n\nexports.DirectSecp256k1Wallet = DirectSecp256k1Wallet;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAIA;AAEA;;;;;;;AAKA,MAAaA,qBAAb,CAAkC;AAgBhCC,cAAoBC,OAApB,EAAyCC,MAAzC,EAA6DC,MAA7D,EAA2E;AACzE,SAAKF,OAAL,GAAeA,OAAf;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD;AAnBD;;;;;;;;AAM2B,eAAPC,OAAO,CAACH,OAAD,EAAuC;AAAA,QAAjBE,MAAiB,uEAAR,QAAQ;AAChE,UAAME,YAAY,GAAG,CAAC,MAAMC,mBAAUC,WAAV,CAAsBN,OAAtB,CAAP,EAAuCC,MAA5D;AACA,WAAO,IAAIH,qBAAJ,CAA0BE,OAA1B,EAAmCK,mBAAUE,cAAV,CAAyBH,YAAzB,CAAnC,EAA2EF,MAA3E,CAAP;AACD;;AAYkB,MAAPM,OAAO;AACjB,WAAOC,kBAAOC,MAAP,CAAc,KAAKR,MAAnB,EAA2BS,uCAA+B,KAAKV,MAApC,CAA3B,CAAP;AACD;;AAEuB,QAAXW,WAAW;AACtB,WAAO,CACL;AACEC,UAAI,EAAE,WADR;AAEEL,aAAO,EAAE,KAAKA,OAFhB;AAGEP,YAAM,EAAE,KAAKA;AAHf,KADK,CAAP;AAOD;;AAEsB,QAAVa,UAAU,CAACN,OAAD,EAAkBO,OAAlB,EAAkC;AACvD,UAAMC,SAAS,GAAGC,wBAAcF,OAAd,CAAlB;;AACA,QAAIP,OAAO,KAAK,KAAKA,OAArB,EAA8B;AAC5B,YAAM,IAAIU,KAAJ,CAAU,WAAWV,OAAO,sBAA5B,CAAN;AACD;;AACD,UAAMW,aAAa,GAAGd,gBAAOW,SAAP,CAAtB;AACA,UAAMI,SAAS,GAAG,MAAMf,mBAAUgB,eAAV,CAA0BF,aAA1B,EAAyC,KAAKnB,OAA9C,CAAxB;AACA,UAAMsB,cAAc,GAAG,IAAIC,UAAJ,CAAe,CAAC,GAAGH,SAAS,CAACI,CAAV,CAAY,EAAZ,CAAJ,EAAqB,GAAGJ,SAAS,CAACK,CAAV,CAAY,EAAZ,CAAxB,CAAf,CAAvB;AACA,UAAMC,YAAY,GAAGf,iCAAyB,KAAKV,MAA9B,EAAsCqB,cAAtC,CAArB;AACA,WAAO;AACLK,YAAM,EAAEZ,OADH;AAELK,eAAS,EAAEM;AAFN,KAAP;AAID;;AAjD+B;;AAAlCE","names":["DirectSecp256k1Wallet","constructor","privkey","pubkey","prefix","fromKey","uncompressed","crypto_1","makeKeypair","compressPubkey","address","encoding_1","encode","amino_1","getAccounts","algo","signDirect","signDoc","signBytes","signing_1","Error","hashedMessage","signature","createSignature","signatureBytes","Uint8Array","r","s","stdSignature","signed","exports"],"sourceRoot":"","sources":["../src/directsecp256k1wallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}