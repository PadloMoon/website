{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = void 0;\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nfunction compress(proof) {\n  if (!proof.batch) {\n    return proof;\n  }\n\n  return {\n    compressed: compressBatch(proof.batch)\n  };\n}\n\nexports.compress = compress;\n\nfunction decompress(proof) {\n  if (!proof.compressed) {\n    return proof;\n  }\n\n  return {\n    batch: decompressBatch(proof.compressed)\n  };\n}\n\nexports.decompress = decompress;\n\nfunction compressBatch(proof) {\n  const centries = [];\n  const lookup = [];\n  const registry = new Map();\n\n  for (const entry of proof.entries) {\n    if (entry.exist) {\n      const centry = {\n        exist: compressExist(entry.exist, lookup, registry)\n      };\n      centries.push(centry);\n    } else if (entry.nonexist) {\n      const non = entry.nonexist;\n      const centry = {\n        nonexist: {\n          key: non.key,\n          left: compressExist(non.left, lookup, registry),\n          right: compressExist(non.right, lookup, registry)\n        }\n      };\n      centries.push(centry);\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  }\n\n  return {\n    entries: centries,\n    lookupInners: lookup\n  };\n}\n\nfunction compressExist(exist, lookup, registry) {\n  if (!exist) {\n    return undefined;\n  }\n\n  const path = exist.path.map(inner => {\n    const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n    let idx = registry.get(sig);\n\n    if (idx === undefined) {\n      idx = lookup.length;\n      lookup.push(inner);\n      registry.set(sig, idx);\n    }\n\n    return idx;\n  });\n  return {\n    key: exist.key,\n    value: exist.value,\n    leaf: exist.leaf,\n    path\n  };\n}\n\nfunction decompressBatch(proof) {\n  const lookup = proof.lookupInners;\n  const entries = proof.entries.map(comp => {\n    if (comp.exist) {\n      return {\n        exist: decompressExist(comp.exist, lookup)\n      };\n    } else if (comp.nonexist) {\n      const non = comp.nonexist;\n      return {\n        nonexist: {\n          key: non.key,\n          left: decompressExist(non.left, lookup),\n          right: decompressExist(non.right, lookup)\n        }\n      };\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  });\n  return {\n    entries\n  };\n}\n\nfunction decompressExist(exist, lookup) {\n  if (!exist) {\n    return undefined;\n  }\n\n  const {\n    key,\n    value,\n    leaf,\n    path\n  } = exist;\n  const newPath = (path || []).map(idx => lookup[idx]);\n  return {\n    key,\n    value,\n    leaf,\n    path: newPath\n  };\n}","map":{"version":3,"mappings":"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","names":["compress","proof","batch","compressed","compressBatch","exports","decompress","decompressBatch","centries","lookup","registry","Map","entry","entries","exist","centry","compressExist","push","nonexist","non","key","left","right","Error","lookupInners","undefined","path","map","inner","sig","codecimpl_1","InnerOp","encode","finish","idx","get","length","set","value","leaf","comp","decompressExist","newPath"],"sourceRoot":"","sources":["../src/compress.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}