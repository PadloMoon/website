{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst addresses_1 = require(\"./addresses\");\n\nconst paths_1 = require(\"./paths\");\n\nconst signature_1 = require(\"./signature\");\n\nconst signdoc_1 = require(\"./signdoc\");\n\nconst wallet_1 = require(\"./wallet\");\n\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\n\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isDerivationJson(thing) {\n  if (!utils_1.isNonNullObject(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [paths_1.makeCosmoshubPath(0)],\n  prefix: \"cosmos\"\n};\n\nclass Secp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n\n    const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async fromMnemonic(mnemonic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new Secp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), {\n      seed: seed\n    }));\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async generate() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n    switch (root.type) {\n      case serializationTypeV1:\n        return Secp256k1HdWallet.deserializeTypeV1(serialization, password);\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n\n\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          utils_1.assert(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n\n          const firstPrefix = accounts[0].prefix;\n\n          if (!accounts.every(_ref => {\n            let {\n              prefix\n            } = _ref;\n            return prefix === firstPrefix;\n          })) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n\n          const hdPaths = accounts.map(_ref2 => {\n            let {\n              hdPath\n            } = _ref2;\n            return crypto_1.stringToPath(hdPath);\n          });\n          return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n    return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n\n  get mnemonic() {\n    return this.secret.toString();\n  }\n\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(_ref3 => {\n      let {\n        algo,\n        pubkey,\n        address\n      } = _ref3;\n      return {\n        algo: algo,\n        pubkey: pubkey,\n        address: address\n      };\n    });\n  }\n\n  async signAmino(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(_ref4 => {\n      let {\n        address\n      } = _ref4;\n      return address === signerAddress;\n    });\n\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const message = crypto_1.sha256(signdoc_1.serializeSignDoc(signDoc));\n    const signature = await crypto_1.Secp256k1.createSignature(message, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    return {\n      signed: signDoc,\n      signature: signature_1.encodeSecp256k1Signature(pubkey, signatureBytes)\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n\n\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(_ref5 => {\n        let {\n          hdPath,\n          prefix\n        } = _ref5;\n        return {\n          hdPath: crypto_1.pathToString(hdPath),\n          prefix: prefix\n        };\n      })\n    };\n    const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: encoding_1.toBase64(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async _ref6 => {\n      let {\n        hdPath,\n        prefix\n      } = _ref6;\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = encoding_1.Bech32.encode(prefix, addresses_1.rawSecp256k1PubkeyToRawAddress(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n\n}\n\nexports.Secp256k1HdWallet = Secp256k1HdWallet;","map":{"version":3,"mappings":"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","names":["serializationTypeV1","basicPasswordHashingOptions","algorithm","params","outputLength","opsLimit","memLimitKib","isDerivationJson","thing","utils_1","hdPath","prefix","extractKdfConfigurationV1","doc","kdf","extractKdfConfiguration","serialization","root","JSON","parse","Error","type","exports","defaultOptions","bip39Password","hdPaths","paths_1","Secp256k1HdWallet","constructor","mnemonic","options","_a","_b","secret","seed","accounts","map","fromMnemonic","mnemonicChecked","crypto_1","mnemonicToSeed","Object","generate","length","entropyLength","Math","floor","entropy","getBytes","encode","toString","deserialize","password","deserializeTypeV1","deserializeWithEncryptionKey","encryptionKey","untypedRoot","decryptedBytes","wallet_1","encoding_1","data","encryption","decryptedDocument","Array","isArray","every","account","firstPrefix","getAccounts","accountsWithPrivkeys","getAccountsWithPrivkeys","algo","pubkey","address","signAmino","signerAddress","signDoc","find","undefined","privkey","message","signdoc_1","signature","createSignature","signatureBytes","Uint8Array","r","s","signed","signature_1","serialize","kdfConfiguration","serializeWithEncryptionKey","dataToEncrypt","dataToEncryptRaw","stringify","encryptionConfiguration","xchacha20poly1305Ietf","encryptedData","out","getKeyPair","derivePath","Secp256k1","makeKeypair","compressPubkey","Promise","all","addresses_1"],"sourceRoot":"","sources":["../src/secp256k1hdwallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}