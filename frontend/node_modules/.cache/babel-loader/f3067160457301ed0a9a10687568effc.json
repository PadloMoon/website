{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nconst ops_1 = require(\"./ops\");\n\nconst specs_1 = require(\"./specs\");\n\nexports.iavlSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 4,\n    maxPrefixLength: 12,\n    childSize: 33,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.tendermintSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    childSize: 32,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.smtSpec = {\n  leafSpec: {\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n    prefix: Uint8Array.from([0])\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    childSize: 32,\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    emptyChild: new Uint8Array(32),\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  },\n  maxDepth: 256\n}; // verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\n\nfunction verifyExistence(proof, spec, root, key, value) {\n  ensureSpec(proof, spec);\n  const calc = calculateExistenceRoot(proof);\n  (0, specs_1.ensureBytesEqual)(calc, root);\n  (0, specs_1.ensureBytesEqual)(key, proof.key);\n  (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\n\nexports.verifyExistence = verifyExistence; // Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\n\nfunction verifyNonExistence(proof, spec, root, key) {\n  let leftKey;\n  let rightKey;\n\n  if (proof.left) {\n    verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n    leftKey = proof.left.key;\n  }\n\n  if (proof.right) {\n    verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n    rightKey = proof.right.key;\n  }\n\n  if (!leftKey && !rightKey) {\n    throw new Error(\"neither left nor right proof defined\");\n  }\n\n  if (leftKey) {\n    (0, specs_1.ensureBytesBefore)(leftKey, key);\n  }\n\n  if (rightKey) {\n    (0, specs_1.ensureBytesBefore)(key, rightKey);\n  }\n\n  if (!spec.innerSpec) {\n    throw new Error(\"no inner spec\");\n  }\n\n  if (!leftKey) {\n    ensureLeftMost(spec.innerSpec, proof.right.path);\n  } else if (!rightKey) {\n    ensureRightMost(spec.innerSpec, proof.left.path);\n  } else {\n    ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n  }\n\n  return;\n}\n\nexports.verifyNonExistence = verifyNonExistence; // Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\n\nfunction calculateExistenceRoot(proof) {\n  if (!proof.key || !proof.value) {\n    throw new Error(\"Existence proof needs key and value set\");\n  }\n\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n\n  const path = proof.path || [];\n  let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n\n  for (const inner of path) {\n    res = (0, ops_1.applyInner)(inner, res);\n  }\n\n  return res;\n}\n\nexports.calculateExistenceRoot = calculateExistenceRoot; // ensureSpec throws an Error if proof doesn't fulfill spec\n\nfunction ensureSpec(proof, spec) {\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n\n  if (!spec.leafSpec) {\n    throw new Error(\"Spec must include leafSpec\");\n  }\n\n  if (!spec.innerSpec) {\n    throw new Error(\"Spec must include innerSpec\");\n  }\n\n  (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n  const path = proof.path || [];\n\n  if (spec.minDepth && path.length < spec.minDepth) {\n    throw new Error(`Too few inner nodes ${path.length}`);\n  }\n\n  if (spec.maxDepth && path.length > spec.maxDepth) {\n    throw new Error(`Too many inner nodes ${path.length}`);\n  }\n\n  for (const inner of path) {\n    (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n  }\n}\n\nexports.ensureSpec = ensureSpec;\n\nfunction ensureLeftMost(spec, path) {\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, 0); // ensure every step has a prefix and suffix defined to be leftmost\n\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\n\nfunction ensureRightMost(spec, path) {\n  const len = spec.childOrder.length - 1;\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, len); // ensure every step has a prefix and suffix defined to be leftmost\n\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\n\nfunction ensureLeftNeighbor(spec, left, right) {\n  const mutleft = [...left];\n  const mutright = [...right];\n  let topleft = mutleft.pop();\n  let topright = mutright.pop();\n\n  while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n    topleft = mutleft.pop();\n    topright = mutright.pop();\n  } // now topleft and topright are the first divergent nodes\n  // make sure they are left and right of each other\n\n\n  if (!isLeftStep(spec, topleft, topright)) {\n    throw new Error(`Not left neightbor at first divergent step`);\n  } // make sure the paths are left and right most possibilities respectively\n\n\n  ensureRightMost(spec, mutleft);\n  ensureLeftMost(spec, mutright);\n}\n\nexports.ensureLeftNeighbor = ensureLeftNeighbor; // isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\n\nfunction isLeftStep(spec, left, right) {\n  const leftidx = orderFromPadding(spec, left);\n  const rightidx = orderFromPadding(spec, right);\n  return rightidx === leftidx + 1;\n}\n\nfunction orderFromPadding(spec, inner) {\n  for (let branch = 0; branch < spec.childOrder.length; branch++) {\n    const {\n      minPrefix,\n      maxPrefix,\n      suffix\n    } = getPadding(spec, branch);\n\n    if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n      return branch;\n    }\n  }\n\n  throw new Error(`Cannot find any valid spacing for this node`);\n}\n\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n  if ((op.prefix || []).length < minPrefix) {\n    return false;\n  }\n\n  if ((op.prefix || []).length > maxPrefix) {\n    return false;\n  }\n\n  return (op.suffix || []).length === suffix;\n}\n\nfunction getPadding(spec, branch) {\n  const idx = getPosition(spec.childOrder, branch); // count how many children are in the prefix\n\n  const prefix = idx * spec.childSize;\n  const minPrefix = prefix + spec.minPrefixLength;\n  const maxPrefix = prefix + spec.maxPrefixLength; // count how many children are in the suffix\n\n  const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n  return {\n    minPrefix,\n    maxPrefix,\n    suffix\n  };\n}\n\nfunction getPosition(order, branch) {\n  if (branch < 0 || branch >= order.length) {\n    throw new Error(`Invalid branch: ${branch}`);\n  }\n\n  return order.findIndex(val => val === branch);\n}","map":{"version":3,"mappings":"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","names":["exports","leafSpec","prefix","Uint8Array","from","hash","codecimpl_1","HashOp","SHA256","prehashValue","prehashKey","NO_HASH","length","LengthOp","VAR_PROTO","innerSpec","childOrder","minPrefixLength","maxPrefixLength","childSize","NO_PREFIX","emptyChild","maxDepth","verifyExistence","proof","spec","root","key","value","ensureSpec","calc","calculateExistenceRoot","verifyNonExistence","leftKey","rightKey","left","right","Error","ensureLeftMost","path","ensureRightMost","ensureLeftNeighbor","leaf","res","inner","minDepth","minPrefix","maxPrefix","suffix","getPadding","step","hasPadding","len","mutleft","mutright","topleft","pop","topright","isLeftStep","leftidx","orderFromPadding","rightidx","branch","op","idx","getPosition","order","findIndex","val"],"sourceRoot":"","sources":["../src/proofs.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}