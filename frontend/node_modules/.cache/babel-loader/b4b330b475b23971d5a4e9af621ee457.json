{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst xstream_1 = require(\"xstream\");\n\nconst streamingsocket_1 = require(\"./streamingsocket\");\n\nvar ConnectionStatus;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n  ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\n\n\nclass QueueingStreamingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    this.queue = [];\n    this.isProcessingQueue = false;\n    this.url = url;\n    this.timeout = timeout;\n    this.reconnectedHandler = reconnectedHandler;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n    this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n  }\n\n  connect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n    this.socket.connected.then(async () => {\n      this.connectionStatusProducer.update(ConnectionStatus.Connected);\n      return this.processQueue();\n    }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n    this.socket.connect();\n  }\n\n  disconnect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n    this.socket.disconnect();\n  }\n\n  reconnect() {\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    }); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this.socket.connected.then(() => {\n      if (this.reconnectedHandler) {\n        this.reconnectedHandler();\n      }\n    });\n    this.connect();\n  }\n\n  getQueueLength() {\n    return this.queue.length;\n  }\n\n  queueRequest(request) {\n    this.queue.push(request); // We donâ€™t need to wait for the queue to be processed.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this.processQueue();\n  }\n\n  async processQueue() {\n    if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n    let request;\n\n    while (request = this.queue.shift()) {\n      try {\n        await this.socket.send(request);\n        this.isProcessingQueue = false;\n      } catch (error) {\n        // Probably the connection is down; will try again automatically when reconnected.\n        this.queue.unshift(request);\n        this.isProcessingQueue = false;\n        return;\n      }\n    }\n  }\n\n}\n\nexports.QueueingStreamingSocket = QueueingStreamingSocket;","map":{"version":3,"mappings":"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","names":["ConnectionStatus","exports","QueueingStreamingSocket","constructor","url","timeout","reconnectedHandler","eventProducer","start","listener","eventProducerListener","stop","undefined","events","xstream_1","create","connectionStatusProducer","stream_1","Unconnected","connectionStatus","socket","streamingsocket_1","subscribe","next","event","Error","error","update","Disconnected","connect","Connecting","connected","then","Connected","processQueue","disconnect","reconnect","getQueueLength","queue","length","queueRequest","request","push","isProcessingQueue","value","shift","send","unshift"],"sourceRoot":"","sources":["../src/queueingstreamingsocket.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}